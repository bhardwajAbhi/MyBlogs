{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Home", "text": ""}, {"location": "#hi-there--\u0928\u092e\u0938\u0924-namaste", "title": "Hi there \ud83d\udc4b, \u0928\u092e\u0938\u094d\u0924\u0947 (Namaste)\ud83d\ude4f\ud83c\udffb", "text": "<p>I\u2019m Abhishek Bhardwaj  I\u2019m an Android App developer, who designs and develops beautiful native Android apps.</p>"}, {"location": "#posts", "title": "Posts", "text": "<p>Every post is a bit of what I\u2019ve learned lately. See if there\u2019s something you like.</p> <p>Read Posts</p>"}, {"location": "#projects", "title": "Projects", "text": "<p>Take a peek at the projects I\u2019ve taken on during my free time for learning. Ready to team up?</p> <p>See Projects</p>"}, {"location": "#github-stats", "title": "GitHub Stats", "text": "<p>Using GitHub Stats and Top Langs by  anuraghazra</p>"}, {"location": "posts/mobile-security/android-secure-coding-practices/", "title": "Secure Coding Practices", "text": "", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#introduction", "title": "Introduction", "text": "<p>With the Android platform fast becoming a target of malicious hackers, applications security is no longer an add-on, but a crucial part of the developer\u2019s job.</p> <p>This post provides secure coding practices that a developer need to follow in order to design and implement robust, rugged, and secure apps for Android device.</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#1-verify-for-security-early-and-often", "title": "1. Verify for Security Early and Often", "text": "", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#securing-application-components", "title": "Securing Application Components", "text": "<ul> <li> <p>Application Components are the essential building blocks of an Android Application.</p> </li> <li> <p>Each component is an entry point through which the system or a user can enter your application.</p> </li> <li> <p>Four major Android Application Components are: </p> <ul> <li>Activities</li> <li>Services</li> <li>Content Providers</li> <li>Broadcast Receivers</li> </ul> </li> <li> <p>One of the common mistakes while developing applications is unintentionally leaving application components exposed.</p> </li> <li> <p>Application components can be secured both by making proper use of the AndroidManifest.xml file and by forcing permission checks at code level.</p> </li> <li> <p>These two factors of application security make the permissions framework quite flexible and allow you to limit the number of applications accessing your components in quite a granular way.</p> </li> <li> <p>The android:exported attribute defines whether a component can be invoked by other applications.</p> </li> <li> <p>If any of your application components do not need to be invoked by other applications or need to be explicitly shielded from interaction with the components on the rest of the Android system (other than components internal to your application)</p> </li> <li> <p>You should add the following attribute to the application component\u2019s XML element:</p> </li> </ul> AndroidManifest.xml<pre><code>&lt;[component-name] android:exported=\"false\"&gt;\n...\n&lt;/[component-name]&gt;\n</code></pre> <ul> <li>Here the [component name] would either be an activity, provider, service or a receiver.</li> </ul>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#protecting-components-with-custom-permissions", "title": "Protecting components with Custom Permissions", "text": "<ul> <li> <p>The Android platform defines a set of default permissions which are used to secure system services and application components.</p> </li> <li> <p>Largely, these permissions work in the most generic case, but often when sharing bespoke functionality or components between applications it will require a more tailored use of the permissions framework.</p> </li> <li> <p>This is facilitated by defining custom permissions.</p> </li> </ul> <p>Following snippets demonstrates how you can define your own custom permissions:</p> <ol> <li> <p>Before adding any custom permissions, you need to declare string resources for the permission labels. You can do this by editing the strings.xml file in your application project folder under res/values/strings.xml: res/values/strings.xml<pre><code>&lt;string name=\"custom_permission_label\"&gt;Custom Permission&lt;/string&gt;\n</code></pre></p> </li> <li> <p>Adding normal protection-level custom permissions to your application can be done by adding the following lines to your AndroidManifest.xml file: AndroidManifest.xml<pre><code>&lt;permission android:name=\"android.permission.CUSTOM_PERMISSION\"\nandroid:protectionLevel=\"normal\"\nandroid:description=\"my custom permission\"\nandroid:label=\"@string/custom_permission_label\"&gt;\n</code></pre></p> </li> <li> <p>Making use of this permission works the same as any other permission; you need to add it to the android:permission attribute of an application component. AndroidManifest.xml<pre><code>&lt;[component-name] ...\nandroid:permission=\"android.permission.CUSTOM_PERMISSION\"&gt;\n&lt;/[component-name]&gt;\n</code></pre> Here the [component name] would either be an activity, provider, service or a receiver.</p> </li> <li> <p>You can also allow other applications to request this permission by adding the &lt;uses-permission/&gt; tag to an application\u2019s AndroidManifest.xml file: AndroidManifest.xml<pre><code>&lt;uses-permission android:name=\"android.permission.CUSTOM_PERMISSION\"/&gt;\n</code></pre></p> </li> </ol> <p>The breakdown of the attributes of &lt;permission&gt; element is as follows:</p> <ul> <li> <p>android:name - This defines the name of the permissions, which is the string value that will be used to reference this permission.</p> </li> <li> <p>android:protectionLevel - This defines the protection level of the permission and controls whether users will be prompted to grant the permission. Following are the Protection Levels:</p> <ul> <li> <p>normal -  This permission is used to define non dangerous permissions, these permissions will not be prompted and may be granted autonomously.</p> </li> <li> <p>dangerous - This permission is used to define permissions that expose the user to considerable fiscal, reputational, and legal risk.</p> </li> <li> <p>signature -  This permission is granted autonomously to applications that are signed with the same key as the application that defines them.</p> </li> <li> <p>signatureOrSystem - This permission is automatically granted to any application that forms a part of the system image or is signed with the same key as the application that defines them.</p> </li> </ul> </li> </ul>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#2-parameterized-queries", "title": "2. Parameterized Queries", "text": "", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#sql-injection", "title": "SQL Injection", "text": "<ul> <li> <p>One specific form of a class of vulnerabilities known as command injection.</p> </li> <li> <p>In this type of vulnerability, input from an outside source is used directly as part of a command, in this case a SQL expression that is passed to a database interpreter.</p> </li> </ul> <p>For Example:</p> <ul> <li> <p>consider a case where the user supplies a username and password to an application, which must then verify that the combination is valid to allow access. <pre><code>String loginQuery = \"SELECT * FROM useraccounts WHERE userID = '\" + request.getParameter(\"userID\") + \"' AND password = '\" + request.getParameter(\"password\") + \"'\";\n</code></pre></p> </li> <li> <p>However, if whoever is submitting the information were to submit these values: <pre><code>userID = ' or 1=1 --\npassword = doesNotMatter\n</code></pre></p> </li> <li> <p>The resulting query that would be supplied to the SQL database interpreter would be: <pre><code>SELECT * FROM useraccounts WHERE userID='' or 1=1 -- AND password='doesNotMatter'\n</code></pre> This SQL statement would then evaluate and return all of the data from the user accounts table, as the WHERE condition would always be true (due to the OR 1=1 condition) and the password checking clause would be commented out.</p> </li> </ul> <p>This unintended behavior is made possible because of two primary problems.</p> <ul> <li> <p>First, our app did not properly validate the input that was received before using that input to form the SQL statement to be submitted to the database interpreter.</p> </li> <li> <p>Second, the problem is enabled because when query strings are constructed in such a manner, the database system cannot tell the difference between code and data; the initial apostrophe (\u2018) submitted in the userID is actually data, but is being interpreted as code because the database cannot tell that it should be interpreted as a literal data value.</p> </li> </ul>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#preventing-command-injection", "title": "Preventing Command Injection", "text": "<ul> <li> <p>Looking at an example similar to the earlier one.</p> </li> <li> <p>Let\u2019s consider looking up a user\u2019s last name in a database. The unsafe way to form this statement looks something like this: Non-Compliant Code<pre><code>SQLiteDatabase db = dbHelper.getWriteableDatabase();\nString userQuery = \"SELECT lastName FROM useraccounts WHERE userID = \" + request.getParameter(\"userID\");\nString userLastName = prepStatement.simpleQueryForString();\n</code></pre></p> </li> <li> <p>Here is the proper way to perform such a query against the database, where the command is separated from the data: Compliant Code<pre><code>SQLiteDatabase db = dbHelper.getWriteableDatabase();\nString userQuery = \"SELECT lastName FROM useraccounts WHERE userID = ?\";\nSQLiteStatement prepStatement = db.compileStatement (userQuery);\nprepStatement.bindString(1, request.getParameter(\"userID\")); String userLastName = prepStatement.simpleQueryForString();\n</code></pre></p> </li> </ul> <p>By taking advantage of the compileStatement capability, we can effectively separate commands from data in SQL statements, by using the ? marker. This is known as a parameterized query, as the query string includes placeholders (question marks) to mark the data and the values for those pieces of data are filled in independently (by the bindString() call in our example).</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#3-encode-data", "title": "3. Encode Data", "text": "<ul> <li> <p>Encoding your data is a solution you should consider if you work with slightly less sensitive data or are looking for a way to organize your data.</p> </li> <li> <p>Most encoding methods rely on algorithms to compress the data and reduce its complexity.</p> </li> <li> <p>The same algorithm used to encode the data is needed to access the data in a readable format.</p> </li> <li> <p>Encoding keeps your data safe since the data is not readable unless you have access to the algorithms that were used to encode it.</p> </li> <li> <p>This is a good way to protect your data from theft since any stolen data would not be usable.</p> </li> <li> <p>Encoding is an ideal solution if you need to have third parties access your data but do not want to have everyone be able to access some sensitive data.</p> </li> <li> <p>Since encoding removes redundancies from data, the size of your data will be a lot smaller.</p> </li> <li> <p>This results in faster input speed when data is processed or saved. Since encoded data is smaller in size, you should be able to save space on your storage devices.</p> </li> <li> <p>Encoded data is easy to organize, even if the original data was mostly unstructured.</p> </li> <li> <p>This is how we can encode a normal string to a Base64 encoding scheme. <pre><code>String testValue = \"Hello, world!\";\nbyte[] encodeValue = Base64.encode(testValue.getBytes(), Base64.DEFAULT);\nbyte[] decodeValue = Base64.decode(encodeValue, Base64.DEFAULT);\nLog.d(\"ENCODE_DECODE\", \"defaultValue = \" + testValue);\nLog.d(\"ENCODE_DECODE\", \"encodeValue = \" + new String(encodeValue));\nLog.d(\"ENCODE_DECODE\", \"decodeValue = \" + new String(decodeValue));\n</code></pre> Output<pre><code>defaultValue = Hello, world!\nencodeValue = SGVsbG8sIHdvcmxkIQ==\ndecodeValue = Hello, world!\n</code></pre></p> </li> </ul>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#4-validate-all-inputs", "title": "4. Validate All Inputs", "text": "<ul> <li> <p>Input validation is the key component of application security.</p> </li> <li> <p>One of the primary problems in applications is that developers trust that input.</p> </li> <li> <p>Remember that any piece of data submitted from outside your app can be submitted by, or manipulated by, an attacker.</p> </li> <li> <p>You need to verify that the data received by your application is valid and safe to process.</p> </li> <li> <p>Validating input data is the easiest and yet most effective secure coding method.</p> </li> <li> <p>All data that is inputted into the application either directly or indirectly by an outside source needs to be properly validated.</p> </li> </ul> <p>For Example:</p> <ul> <li> <p>Following is an example of an Activity as used in a program that receives data from Intent: Non-Compliant Code<pre><code>TextView tv = (TextView) findViewById(R.id.textview);\nInputStreamReader isr = null;\nchar [] text = new char[1024];\nint read;\ntry {\nString urlstr = getIntent().getStringExtra(\"WEBPAGE_URL\");\nURL url = new URL(urlstr);\nisr = new InputStreamReader(url.openConnection().getInputStream());\nwhile((read=isr.read(text)) != -1) {\ntv.append(new String(text, 0, read));\n}\n} catch (MalformedURLException e) {...}\n</code></pre></p> </li> <li> <p>The example is a simple sample where HTML is acquired from a remote web page in a designated URL and the code is displayed in TextView.</p> </li> <li> <p>However, this is not sufficient.</p> </li> <li> <p>Furthermore, when a \u201cfile://\u2026\u201d formatted URL is designated by urlstr, the file of the internal file system is opened and is displayed in TextView rather than the remote web page.</p> </li> <li> <p>The below example shows a revision to fix the security bugs: Compliant Code<pre><code>TextView tv = (TextView) findViewById(R.id.textview);\nInputStreamReader isr = null;\nchar [] text = new char[1024];\nint read;\ntry {\nString urlstr = getIntent().getStringExtra(\"WEBPAGE_URL\");\nURL url = new URL(urlstr);\nString prot = url.getProtocol();\nif(!\"http\".equals(prot) &amp;&amp; !\"https\".equals(prot)) {\nthrow new MalformedURLException(\"invalid protocol\");\n}\nisr = new InputStreamReader(url.openConnection().getInputStream());\nwhile((read=isr.read(text)) != -1) {\ntv.append(new String(text, 0, read));\n}\n} catch (MalformedURLException e) {...}\n</code></pre></p> </li> </ul> <p>Validating the safety of input data is called \u201cInput Validation\u201d and it is a fundamental secure coding method.</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#5-implement-identity-and-authentication-controls", "title": "5. Implement Identity and Authentication Controls", "text": "<ul> <li> <p>Providing a secure login mechanism for your users is harder than on the Web.</p> </li> <li> <p>The trend on mobile devices is to make things as easy as possible for the user.</p> </li> <li> <p>But if you make it too easy to login into your app, you run the risk of unauthorized users gaining access to sensitive data by going around this authentication.</p> </li> <li> <p>The following tokens are common on Android devices as a part of login process:</p> <ul> <li>Username and Password</li> <li>Device information, such as DeviceID and AndroidID</li> <li>Network information, such as IP address</li> </ul> </li> <li> <p>The classic login of username and password is still the most common authentication on an Android phone.</p> </li> <li> <p>Let\u2019s look at some best practices for user authentication. </p> </li> <li> <p>The best practices are as follows:</p> <ul> <li>No password caching</li> <li>Minimum password length</li> <li>Multi-factor authentication</li> <li>Server-side as well as client-side authentication</li> </ul> </li> <li> <p>Do not save or cache username, and especially password, information on the phone, as there is always a risk that it will be found and decrypted. </p> </li> <li> <p>Even if you\u2019re encrypting the password, if you\u2019re also storing the key in the APK then it\u2019s going to be unencrypted.</p> </li> <li> <p>It is better not to store passwords, if you can get away with it, and make the user Log In each time.</p> </li> <li> <p>Try to enforce a minimum password length - passwords of less than six characters are highly prone to a brute force attack. Financial apps should have stricter policies than other apps.</p> </li> <li> <p>Validate email addresses - this can be done either using regular expressions or via an email link during setup or, better still, using both approaches.</p> </li> <li> <p>If you do update your password standards, notify your existing customers when they login again to update their passwords.</p> </li> <li> <p>It\u2019s becoming very common for applications to use a Two-Factor Authentication where a randomly generated PIN number is sent via SMS message to user\u2019s phone before he can log in to the application. </p> </li> <li> <p>We can also use the info like DeviceID, IP Address, and Location information to add extra layers of information.</p> </li> <li> <p>Access control doesn\u2019t end at the client; it needs to be enforced at the server, too. </p> </li> <li> <p>Some back-end servers mistakenly rely on the client app to perform all authentication and assume that the web server doesn\u2019t need to do any authentication.</p> </li> <li> <p>The server should also check for valid credentials each time or use a session token once again over SSL.</p> </li> <li> <p>It should also check for unusual activity, such as someone performing a bruteforce attack, and notify the user via email of unusual login activity.</p> </li> <li> <p>If you are saving any personal, healthcare, or financial information, you should use an asymmetric or public/private key. </p> </li> <li> <p>This does require a round trip back to the server to decrypt the data, but if the phone is compromised, the user\u2019s data will remain secure.</p> </li> <li> <p>Only the private key can decrypt the data, and that should never be stored on the phone.</p> </li> </ul>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#6-cryptographically-secure-data", "title": "6. Cryptographically Secure Data", "text": "<ul> <li> <p>Encryption techniques are frequently used to ensure confidentiality and integrity, and Android is equipped with a variety of cryptographic features to allow applications to realize confidentiality and integrity.</p> </li> <li> <p>You may use password-based key encryption for the purpose of protecting a user\u2019s confidential data assets.</p> </li> <li> <p>Key Points to consider while Encrypting and Decrypting with Password-based keys:</p> <ul> <li>Explicitly specify the encryption mode and the padding.</li> <li>Use strong encryption technologies including algorithms, block cipher modes, and padding modes.</li> <li>When generating a key from password, use Salt.</li> <li>When generating a key from password, specify an appropriate hash iteration count.</li> <li>Use a key of length sufficient to guarantee the strength of encryption.</li> </ul> </li> </ul> <p>Here is the complete listing that will allow the encryption or decryption of data based on a password: <pre><code>String password = ... ;\nString PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\nString CIPHER_ALGORITHM = \"AES/CHC/PKCSSPadding\";\nint NUM_OF_ITERATIONS = 1000;\nint KEY_SIZE = 256;\nbyte[] salt = new SecureRandom.nextBytes(new byte[8]);\nbyte[] iv = new SecureRandom.nextBytes(new byte[16]);\nString clearText = ... ; // The value to be encrypted\nbyte[] encryptedText:\nbyte[] decryptedtext;\ntry{\nPBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, NUM_OF_ITERATIONS, KEY_SIZE);\nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\nSecretKey secretKey = keyFactory.generateSecret(pbeKeySpec);\nSecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\nIvParameterSpec ivSpec = new IvParameterSpec(iv):\nCipher encCipher = Cipher.getInstance(CIPHER_ALGORITHM);\nencCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);\nCipher decCipher = Cipher.getinstance(CIPHER_ALGORITHM);\ndecCipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\nencryptedText = encCipher.doFinal(clearText.getBytes());\ndecyptedText = decCipher.doFinal(encryptedText);\nString sameAsClearText = new String(decryptedText);\n} catch (Exception e) {\n...\n}\n</code></pre></p> <p>In the above snippet:</p> <pre><code>String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\nString CIPHER_ALGORITHM = \"AES/CHC/PKCSSPadding\";\nint NUM_OF_ITERATIONS = 1000;\nint KEY_SIZE = 256;\n</code></pre> <ul> <li> <p>This section of code just sets up the algorithms and parameters we are going to use.</p> </li> <li> <p>Here we are using SHA-256 as the Hashing algorithm and AES in CBC mode as the Encryption Algorithm.</p> </li> <li> <p>We will use 1,000 iterations of the hashing function during the process and will end up with a 256-bit key.</p> </li> <li> <p>We will be using AES, still in Cipher Block Chaining mode, and employ PKCS#5 padding. The padding setting specified how to pad the data being encrypted (or decrypted) if it is not in multiples of 128 bits, as AES operates on blocks of 128 bits at a time. </p> </li> <li> <p>These all are standard algorithms and parameters, representing a strong encryption scheme.</p> </li> </ul> <pre><code>byte[] salt = new SecureRandom.nextBytes(new byte[8]);\nbyte[] iv = new SecureRandom.nextBytes(new byte[16]);\n</code></pre> <ul> <li>Here, we set up the Salt that will be used in the key derivation computation and the Initialization Vector (IV) that will be used in encryption and decryption of data.</li> </ul> <pre><code>String clearText = ... ; // The value to be encrypted\nbyte[] encryptedText:\nbyte[] decryptedtext;\n</code></pre> <ul> <li> <p>Here, we just set up the values we will encrypt and decrypt. </p> </li> <li> <p>For the purpose of this example, clearText will hold the string we want to encrypt.</p> </li> <li> <p>encryptedText is a byte array that will hold the encrypted value of the string.</p> </li> <li> <p>decryptedText will hold the decrypted bytes, once we encrypt the string and then decrypt it.</p> </li> </ul> <pre><code>PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, NUM_OF_ITERATIONS, KEY_SIZE);\nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\nSecretKey secretKey = keyFactory.generateSecret(pbeKeySpec);\nSecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n</code></pre> <ul> <li>Here, we perform key derivation, going from the user-supplied password to a 256-bit AES key.</li> </ul> <pre><code>IvParameterSpec ivSpec = new IvParameterSpec(iv):\n</code></pre> <ul> <li>We then set up the Initialization Vector (IV) like this.</li> </ul> <pre><code>Cipher encCipher = Cipher.getInstance(CIPHER_ALGORITHM);\nencCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);\nCipher decCipher = Cipher.getinstance(CIPHER_ALGORITHM);\ndecCipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\n</code></pre> <ul> <li> <p>This is the main section of our example. We use the derived key and IV, along with our specification of what encryption parameters we want to use, to form a Cipher object.</p> </li> <li> <p>We actually create two, one in ENCRYPT_MODE and one in DECRYPT_MODE.</p> </li> <li> <p>Once we have the cipher objects, we can perform encryption and decryption operations.</p> </li> <li> <p>For encryption, we pass the string we want to encrypt (convert into a byte array) to the doFinal() method of the encrypting Cipher object. </p> </li> <li> <p>The encryption operation is performed and the resulting encrypted bytes are returned to us. <pre><code>encryptedText = encCipher.doFinal(clearText.getBytes());\n</code></pre></p> </li> <li> <p>We can also decrypt data using the same approach. In this case, we use the decrypting Cipher object, passing it the encrypted bytes and getting back to plaintext bytes.</p> </li> <li> <p>As we started a string, we can reconstruct it, and the sameAsClearText string will contain exactly the same value as the clearText string. <pre><code>decyptedText = decCipher.doFinal(encryptedText);\nString sameAsClearText = new String(decryptedText);\n</code></pre></p> </li> </ul> <p>And that\u2019s it. We now have a complete solution for protecting stored data, where we take a user-supplied password, derive a symmetric key from it, and encrypt and decrypt data at will, all in a few short lines of code.</p> <p>Once we encrypt the data, we can store it in a file, in a database, or wherever. As long as we keep the symmetric key from compromise, an attacker will not be able to recover the data from its encrypted form.</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#7-implement-logging-and-intrusion-detection", "title": "7. Implement Logging and Intrusion Detection", "text": "", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#tamper-detection", "title": "Tamper Detection", "text": "<p>Tamper or Intrusion detection is the ability of an application to sense that an active attempt to compromise the application\u2019s integrity or the data associated with the application is in progress; the detection of the threat may enable the application to initiate appropriate defensive actions.</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#responding-to-tamper-detection", "title": "Responding to Tamper Detection", "text": "<ul> <li> <p>The obvious and simple solution would be to check for tampering on startup, and if detected, exit the app optionally with a message to the user explaining why.</p> </li> <li> <p>Here look at different checks that may indicate a tampered, compromised, or hostile environment. </p> </li> <li> <p>These are designed to be activated once you are ready for release.</p> </li> </ul>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#detect-if-google-play-store-was-the-installer", "title": "Detect if Google Play store was the installer", "text": "<ul> <li> <p>Detecting if the installer was the Google Play store is a simple check that the package name of the installer app matches that of the Google Play store. </p> </li> <li> <p>Specifically, it checks if the installer package starts with com.google.android.</p> </li> <li> <p>It is a useful check if you are distributed solely through the Google store.</p> </li> </ul> <pre><code>public static boolean checkGooglePlayStore(Context context) {\nString installerPackageName = context.getPackageManager().getInstallerPackageName(context.getPackageName());\nreturn installerPackageName != null &amp; installerPackageName.startsWith(\"com.google.android\");\n}\n</code></pre>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#detect-if-it-runs-on-an-emulator", "title": "Detect if it runs on an Emulator", "text": "<ul> <li> <p>The Java Reflection API makes it possible to inspect classes, methods, and fields at runtime; and in this case, allows us to override the access modifiers that would prevent ordinary code from compiling. </p> </li> <li> <p>The emulator check uses reflection to access a hidden system class, android.os.SystemProperties. </p> </li> </ul> <pre><code>public static boolean isEmulator() {\ntry {\nClass systemPropertyClazz = Class.forName(\"android.os.SystemProperties\");\nboolean kernelQemu = getProperty(systemPropertyClazz,\n\"ro.kernel.qemu\").length() &gt; 0;\nboolean hardwareGoldfish = getProperty(systemPropertyClazz,\n\"ro.hardware\").equals(\"goldfish\");\nboolean modelSdk = getProperty(systemPropertyClazz,\n\"ro.product.model\").equals(\"sdk\");\nif (kernelQemu || hardwareGoldfish || modelSdk) {\nreturn true;\n}\n} catch (Exception e) {\n// error assumes emulator\n}\nreturn false;\n}\nprivate static String getProperty(Class clazz, String propertyName) throws Exception {\nreturn (String) clazz.getMethod(\"get\", new Class[] { String.class })\n.invoke(clazz, new Object[] { propertyName });\n}\n</code></pre> <p> </p> <p>Using hidden APIs can be risky as they can change between Android versions.</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#detect-if-it-runs-on-a-rooted-device", "title": "Detect if it runs on a Rooted Device", "text": "<ul> <li> <p>Rooted devices may contain many apps that process sensitive information, such as banking apps, payment apps, social media, and cloud storage. </p> </li> <li> <p>Malicious downloads can expose your device to hackers. </p> </li> <li> <p>For these reasons, the apps installed on a device need to make sure that the device isn\u2019t rooted.</p> </li> </ul> <pre><code>public static boolean checkRoot(){\nfor(String pathDir : System.getenv(\"PATH\").split(\":\")){\nif(new File(pathDir, \"su\").exists()) {\nreturn true;\n}\n}\nreturn false;\n}\n</code></pre> <p> </p> <p>Use Rootbeer. A simple to use root checking Android library.</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#detect-if-the-app-has-the-debuggable-flag-enabled", "title": "Detect if the app has the \u201cdebuggable\u201d flag enabled", "text": "<p>(something that should only be enabled during development)</p> <ul> <li> <p>When debuggable is enabled, it is possible to connect via the Android Debug Bridge and perform detailed dynamic analysis. </p> </li> <li> <p>The debuggable variable is a simple property of the &lt;application&gt; element in the AndroidManifest.xml file. </p> </li> <li> <p>It is perhaps one of the easiest and most targeted properties to alter in order to perform dynamic analysis.</p> </li> </ul> <pre><code>public static boolean isDebuggable(Context context) {\nreturn (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;\n}\n</code></pre>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#application-signature-verification", "title": "Application Signature Verification", "text": "<ul> <li> <p>Part of the process of an attacker modifying your application\u2019s .apk file breaks the digital signature.</p> </li> <li> <p>This means that, if they want to install the .apk file on an Android device, it will need to be resigned using a different signing key.</p> </li> <li> <p>Fortunately, at runtime, Android apps can query PackageManager to find app signatures.</p> </li> </ul> <pre><code>// CERTIFICATE'S SHA1 Signature\nprivate static String CERTIFICATE SHA1 = \"71920AC9486E087DCBCF5C7F6FEC952135858CC5\";\npublic static boolean validateAppSignature(Context context) {\ntry {\n// get the signature form the package manager\nPackageinfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);\nSignature[] appSignatures = packageInfo.signatures;\n//this sample only checks the first certificate\nfor (Signature signature : appSignatures) {\nbyte[] signatureBytes = signature.toByteArray();\n//calc shal in hex\nString currentSignature = calcSHA1(signatureBytes);\n//compare signatures\nreturn CERTIFICATE SHA1.equalsIgnoreCase{currentSignature);\n}\n} catch (Exception e) {\n// if error assume failed to validate\n}\nreturn false;\n}\nprivate static String calcSHA1(byte[] signature) throws NoSuchAlgorithmException {\nMessageDigest digest = MessageDigest.getInstance(\"SHA1\");\ndigest.update(signature);\nbyte[] signatureHash = digest.digest();\nreturn bytesToHex(signatureHash);\n}\npublic static String bytesToHex(byte[] bytes) {\nfinal char[] hexArray = { '0', '1', '2', '3', '4', '5', '6',\n'7', '8','9', 'A', 'B', 'C', 'D', 'E', 'F' };\nchar[] hexChars = new char[bytes.length * 2];\nint v;\nfor (int j = 0; j &lt; bytes.length; j++) {\nv = bytes[j] &amp; 0xFF;\nhexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];\nhexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];\n}\nreturn new String(hexChars);\n}\n</code></pre> <p> </p> <p>The hash values should not be hardcoded in real world and instead should be retrieved from a server.</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#outputting-log-to-logcat", "title": "Outputting Log to LogCat", "text": "<ul> <li> <p>There\u2019s a logging mechanism called LogCat in Android, and not only system log information but also application log information outputs to the Logcat.</p> </li> <li> <p>Log information in LogCat can be read out from other application in the same device.</p> </li> <li> <p>So the application which outputs sensitive information to LogCat, is considered that it has the vulnerability of the information leakage.</p> </li> <li> <p>From a security point of view, in release version application, it\u2019s preferable that any log should not be output.</p> </li> </ul> <p>Here we look for some ways to output messages to LogCat in a safe manner even in a release version application.</p> <ul> <li>ProGuard - the method to control the Log output in release version application.   ProGuard is one of the optimization tools which automatically delete the unnecessary code like unused methods, etc.</li> </ul> <p>Essentially there are <code>5</code> types of Log output methods:</p> Log Type Description Log.e() ERROR Log.w() WARN Log.i() INFO Log.d() DEBUG Log.v() VERBOSE <ul> <li> <p>It\u2019s recommended to use the following methods for outputting operation log information:</p> <ul> <li>Log.e()           //ERROR</li> <li>Log.w()           //WARN</li> <li>Log.i()           //INFO  </li> </ul> </li> <li> <p>And the following for outputting development log information:</p> <ul> <li>Log.d()           //DEBUG</li> <li>Log.v()           //VERBOSE</li> </ul> </li> </ul> <pre><code>//Sensitive information must not be output by\n// Log.e(D/w()/i()\nLog.e(LOG_TAG, \"Not sensitive information (ERROR)\");\nLog.w(LOG_TAG, \"Not sensitive information (WARN)\");\nLog.i(LOG_TAG, \"Not sensitive information (INFO)\");\n//Sensitive information should be output by\n// Log.d()/v() in case of need.\nLog.d(LOG_TAG, \"sensitive information (DEBUG)\");\nLog.v(LOG_TAG, \"sensitive information (VERBOSE)\");\n</code></pre> <ul> <li> <p>If the application is for release, those two methods would be deleted automatically. </p> </li> <li> <p>ProGuard is used to automatically delete code blocks where Log.d() and Log.v() is called. proguard-project.txt<pre><code>-assumenosideeffects class android.util.log {\npublic static sxx d(...);\npublic static sxx v(...);\n}\n</code></pre> By specifying Log.d() and Log.v() as parameter of <code>-assumenosideeffects</code> option, call for Log.d() and Log.v() are granted as unnecessary code, and those are to be deleted.</p> </li> </ul> <p> Difference of LogCat output between development version application and release version application. </p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#8-leverage-security-frameworks-and-libraries", "title": "8. Leverage Security Frameworks and Libraries", "text": "", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#securing-sharedpreferences-data-with-encrypted-sharedpreferences", "title": "Securing SharedPreferences data with Encrypted SharedPreferences", "text": "<p>Android provides a simple framework for app developers to persistently store key-value pairs of primitive data types.</p> <p>Thanks to the AndroidX Security Library which was recently added.</p> <p>It is a library that wraps the default Android SharedPreferences to encrypt the key-value pairs for protecting them against attackers.</p> <ol> <li> <p>Simply just create or fetch a Master Key from the Android Keystore: <pre><code>MasterKey masterKey = new MasterKey.Builder(context, MasterKey.DEFAULT_MASTER_KEY_ALIAS)\n.setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n.build();\n</code></pre> We\u2019re given a default key generation specification, AES256_GCM, to use for creating the master key and is recommended to use this specification.</p> </li> <li> <p>Now create an instance of EncryptedSharedPreferences which is a wrapper around SharedPreferences and handles all of the encryption. <pre><code>SharedPreferences sharedPreferences = EncryptedSharedPreferences.create(\ncontext,\n\"my_secure_preferences\",\nmasterKey,\nEncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\nEncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM);\n</code></pre> Here <code>\"my_secure_preferences\"</code> is the name of the file in which the preferences will be saved.</p> </li> <li> <p>Once we\u2019ve created our EncryptedSharedPreferences instance, we can use it just like SharedPreferences to store and read values. <pre><code>//Storing a value\nsharedPreferences.edit()\n.putString(\"key\", value)\n.apply()\n//Reading a value\nsharedPreferences.getString(\"key\", \"defaultValue\");\n</code></pre></p> </li> </ol> Standard SharedPreferences fileEncrypted SharedPreferences file <pre><code>&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;\n&lt;map&gt;\n&lt;int name=\"timeout \" value=\"500\" /&gt;\n&lt;boolean name=\"is logged in\" value=\"true\" /&gt;\n&lt;string name=\"title\"&gt;secure coding practices&lt;/string&gt;\n&lt;/map&gt;\n</code></pre> <pre><code>&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;\n&lt;map&gt;\n&lt;string name=\"MIIEpQIBAAKCAQEAYyb6BkBms39I7imXMOOUW1EDJIsbGNs\"&gt;\nHhiXTk3JRgAMuKOwosHLLfaVvRUUT3ICK\n&lt;/string&gt;\n\n&lt;string name=\"TuwbBUOIrAylL9znGBJI87uEi7pWOFwYwX8SZi11KnD2VZ7\"&gt;\nva617hf5imdM+P3KA3Ik50ZwFj1/Ed2\n&lt;/string&gt;\n\n&lt;string name=\"81qCOgn73Uo84Rjk73t1fVNYsPshl119ztma7U\"&gt;\ntEcsr41t50rGWT9/pqlrMC5x503cc\n&lt;/string&gt;\n&lt;/map&gt;\n</code></pre>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#encrypting-a-database-with-sqlcipher", "title": "Encrypting a database with SQLCipher", "text": "<p>SQLCipher is one of the simplest ways to enable secure storage in an Android app, and it\u2019s compatible for devices running Android 2.1+.</p> <p>SQLCipher uses 256-bit AES in CBC mode to encrypt each database page; in addition, each page has its own random initialization vector to further increase security.</p> <p>SQLCipher is a separate implementation of the SQLite database, and rather than implementing its own encryption, it uses the widely used and tested OpenSSL libcrypto library.</p> <ol> <li> <p>There are several ways to handle SQLite database, either by working directly with the SQLiteDatabase object or using SQLiteOpenHelper.  <pre><code>import android.database.sqlite.*;   // Don't use this\nimport net.sqlcipher.database.*;    // Use this instead\n</code></pre> But generally, if you are already using an SQLite database in your app, simply replace the import android.database.sqlite.* statement with import net.sqlcipher.database.*</p> </li> <li> <p>The simplest way to create an encrypted SQLCipher database is to call openOrCreateDatabase(\u2026) with a <code>password</code>: <pre><code>private static final int DB_VERSION = 1;\nprivate static final String DB_NAME = \"my_encrypted_data.db\";\nprivate static final String password = \"some-password\";\npublic void initDB(Context context, String password) {\nSQLiteDatabase.loadLibs(context);\nSQLiteDatabase database = SQLiteDatabase.openOrCreateDatabase(DB_NAME, password, null);\ndatabase.execSQL( \"create table MyTable(a, b)\");\n}\n</code></pre></p> </li> </ol> <p>Rest other operations remain exactly same as that of a normal SQLite database.</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#android-keystore-provider", "title": "Android KeyStore Provider", "text": "<p>In Android 4.3, a new facility was added to allow apps to save private encryption keys in a system keystore called Android KeyStore which restricts access only to the app that created them and it was secured using the device pin code.</p> <p>Specifically, the Android KeyStore is a certificate store, and so only public/private keys can be stored.</p> <ol> <li> <p>Create a handle on your app\u2019s KeyStore: <pre><code>public static final String ANDROID_KEYSTORE = \"AndroidKeyStore\";\npublic void loadKeyStore() {\ntry {\nkeyStore = KeyStore.getInstance(ANDROID_KEYSTORE);\nkeyStore.load(null);\n} catch (Exception e) {\n// TODO: Handle this appropriately in your app\ne.printStackTrace();\n}\n}\n</code></pre></p> </li> <li> <p>Generate and save the app\u2019s key pair: <pre><code>public void generateNewKeyPair(String alias, Context context) throws Exception {\nCalendar start = Calendar.getInstance();\nCalendar end = Calendar.getInstance();\nend.add(1, Calendar.YEAR);  // expires 1 year from today\nKeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context)\n.setAlias(alias)\n.setSubject(new X500Principal(\"CN=\" + alias))\n.setSerialNumber(BigInteger. TEN)\n.setStartDate(start.getTime())\n.setEndDate(end.getTime())\n.build();\n// use the Android keystore\nKeyPairGenerator gen = KeyPairGenerator.getInstance( \"RSA\", ANDROID_KEYSTORE);\ngen.initialize(spec);\n// generates the keypair\ngen.generateKeyPair();\n}\n</code></pre></p> </li> <li> <p>Retrieve the key with a given alias:  <pre><code>public PrivateKey loadPrivateKey(String alias) throws Exception {\nif(!keyStore.isKeyEntry(alias)) {\nLog.e(TAG, \"Could not find key alias: \" + alias);\nreturn null;\n}\nKeyStore.Entry entry = keyStore.getEntry(KEY_ALIAS, null);\nif (!(entry instanceof KeyStore.PrivateKeyEntry)) {\nLog.e(TAG, \"alias: \" + alias + \" is not a private key.\");\nreturn null;\n}\nreturn ((KeyStore.PrivateKeyEntry) entry).getPrivateKey();\n}\n</code></pre></p> </li> </ol>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#generating-a-symmetric-encryption-key", "title": "Generating a Symmetric Encryption Key", "text": "<p>A symmetric key describes a key that is used for both encryption and decryption. To create cryptographically secure encryption keys in general, we use securely generated pseudorandom numbers.</p> <p>AES is the preferred encryption standard to DES, and typically used with key sizes 128 bit and 256 bit.</p> <ol> <li> <p>Write the following function to generate a symmetric AES encrpytion key. <pre><code>public static SecretKey generateAESKey(int keySize) throws NoSuchAlgorithmException {\nfinal SecureRandom random = new SecureRandom();\nfinal KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\ngenerator.init(keySize, random);\nreturn generator.generateKey();\n}\n</code></pre></p> </li> <li> <p>Create a random 32-byte initialization vector (IV) that matches the AES key size of 256 bit. <pre><code>private static IvParameterSpec iv; public static IvParameterSpec getIV() {\nif (iv == null) {\nbyte [] ivByteArray = new byte[32];\n//populate the array with random bytes\nivByteArray = new SecureRandom().nextBytes(ivByteArray);\niv = new IvParameterSpec(ivByteArray);\n}\nreturn iv;\n}\n</code></pre></p> </li> <li> <p>Write the following function to encrypt an arbitrary string. <pre><code>public static byte[] encrypt(String plainText) throws GeneralSecurityException, IOException {\nfinal Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, getKey(), getIV());\nreturn cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n}\npublic static SecretKey getKey() throws NoSuchAlgorithmException {\nif (key == null) {\nkey = generateAESKey(256);\n} return key;\n}\n</code></pre></p> </li> <li> <p>For completeness, the preceding snippet shows how to decrypt. <pre><code>public static String decrypt(String plainText) throws GeneralSecurityException, IOException {\nfinal Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, getKey(), getIV());\nreturn cipher.doFinal(cipherText).toString();\n}\n</code></pre> The only difference is that here we called the Cipher.init() method using the <code>Cipher.DECRYPT_MODE</code> constant.</p> </li> </ol>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#9-monitor-error-and-exception-handling", "title": "9. Monitor Error and Exception Handling", "text": "<p>Exceptions occur when an application gets into an abnormal or error state.</p> <p>Monitor Error and Exception Handling is about ensuring that the app will handle an exception and transition to a safe state without exposing sensitive information via the UI or the app\u2019s logging mechanisms.</p> <ul> <li> <p>Plan for standard Runtime Exceptions (e.g. NullPointerException, IndexOutOfBoundsException, ActivityNotFoundException, CancellationException, SQLException) by creating proper null checks, bound checks, and the like.</p> </li> <li> <p>Make sure that all confidential information handled by high-risk applications is always wiped during execution of the finally blocks. <pre><code>byte[] secret;\ntry {\n//use secret\n} catch (SPECIFICEXCEPTIONCLASS | SPECIFICEXCEPTIONCLASS2 e) {\n// handle any issues\n} finally {\n//clean the secret.\n}\n</code></pre></p> </li> <li> <p>Adding a general exception handler for uncaught exceptions is a best practice for resetting the application\u2019s state when a crash is imminent: <pre><code>public class MemoryCleanerOnCrash implements Thread.UncaughtExceptionHandler {\nprivate static final MemoryCleanerOnCrash S_INSTANCE = new MemoryCleanerOnCrash();\nprivate final List&lt;Thread.UncaughtExceptionHandler&gt; mHandlers = new ArrayList&lt;&gt;();\n//initialize the handler and set it as the default exception handler\npublic static void init() {\nS_INSTANCE.mHandlers.add(Thread.getDefaultUncaughtExceptionHandler());\nThread.setDefaultUncaughtExceptionHandler(S_INSTANCE);\n}\n@Override\npublic void uncaughtException(Thread thread, Throwable ex) {\n//handle the cleanup here\n//....\n//and then show a message to the user if possible given the context\nfor (Thread.UncaughtExceptionHandler handler : mHandlers) {\nhandler.uncaughtException(thread, ex);\n}\n}\n}\n</code></pre></p> </li> <li> <p>Now the handler\u2019s initializer must be called in your custom Application class (e.g., the class that extends Application): <pre><code>@Override\nprotected void attachBaseContext(Context base) {\nsuper.attachBaseContext(base);\nMemoryCleanerOnCrash.init();\n}\n</code></pre></p> </li> </ul>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#10-handling-intents", "title": "10. Handling Intents", "text": "<p>Using an untrusted intent to launch a component, for example, by calling startActivity(); or to return data, for example, by calling setResult(); is dangerous and can allow malicious  apps to cause the following problems:</p> <ul> <li>Steal sensitive files or system data (like SMS messages) from your app.</li> <li>Launch your app\u2019s private components with poisoned arguments.</li> </ul> <p>It is important that your app does not call startActivity, startService, sendBroadcast, or setResult on untrusted intents without validating or sanitizing these intents.</p>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#intent-redirection", "title": "Intent Redirection", "text": "<ul> <li> <p>Some apps contain an Intent Redirection issue which can allow malicious apps to access private app components or files.</p> </li> <li> <p>Intent Redirection occurs when an activity can forward intents to arbitrary components allowing them to reach even unintended private and sensitive ones. </p> </li> <li> <p>Usually, the redirecting activity is intended to launch only a single or a predefined set of activities. </p> </li> <li> <p>Limiting the components that can be reached only to those meant by the developer can eliminate the problem.</p> </li> <li> <p>Generally you can put an Intent to an Intent with: <pre><code>Intent intent = new Intent();\nIntent.putExtra(Intent.EXTRA_INTENT, new Intent());\n</code></pre></p> </li> <li> <p>To retrieve the Intent (from within an Activity) from the intent you can do the following: <pre><code>Intent intent = getIntent().getParcelableExtra(Intent.EXTRA_INTENT);\n</code></pre></p> </li> </ul>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#private-vs-public-components-can-make-the-difference", "title": "Private vs Public components can make the difference", "text": "<p>If the app component does not need to receive intents from other apps then you can make that app component private by setting the <code>android:exported=\"false\"</code> in your app\u2019s AndroidManifest.xml file</p> <pre><code>&lt;[component-name] android:exported=\"false\"&gt;\n...\n&lt;/[component-name]&gt;\n</code></pre>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#validating-the-source-of-the-intent", "title": "Validating the source of the Intent", "text": "<p>You can verify that the originating activity can be trusted using methods like getCallingActivity().</p> <pre><code>//Check if the originating Activity is from trusted package\nif (getCallingActivity().getPackageName().equals(\"desired_package\")) {\nIntent intent = getIntent();\n//extract the nested Intent\nIntent forward = (Intent) intent.getParcelableExtra(\"extra_intent\");\n//redirect the nested Intent\nstartActivity(forward);\n}\n</code></pre>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/android-secure-coding-practices/#make-sure-that-embedded-intent-is-not-harmful", "title": "Make sure that embedded intent is not harmful", "text": "<p>You should verify that the redirected intent:</p> <ul> <li>will not be sent to any of your app\u2019s private components, and</li> <li>will not be sent to an external app\u2019s components.</li> </ul> <p>Apps can check which component will be used to handle the intent before redirecting it using methods like resolveActivity().</p> <pre><code>Intent intent = getIntent();\n//extract the nested Intent\nIntent forward = (Intent) intent.getParcelableExtra(\"extra_intent\");\n//get component name\nComponentName name = forward.resolveActivity(getPackageManager());\n//Check that the package name and class name are as intended\nif (name.getPackageName().equals(\"desired_package\") &amp;&amp; name.getClassName().equals( \"desired_class\")) {\n//redirect the nested Intent\nstartActivity(forward);\n}\n</code></pre>", "tags": ["secure coding, secure coding practices, android security, android best practices"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/", "title": "2023 Mobile Security Trends", "text": "", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#introduction", "title": "Introduction", "text": "<p>Mobile applications and services are essential to our everyday lives both at home and at work. </p> <p>Smartphones have revolutionized the way we communicate, we surf the internet, we do payments, we do gaming and many more.</p> <p> Multi-function capability of a mobile device </p> <p>They have the capability to perform the functionality of  a camera, calculator, barcode reader, credit card scanner, USB thumb drive, eBook reader, audio recorder and many more.</p> <p>This multi-function capability of the device along with the cost and mobility factor has made mobile devices an important part of personal and business life of people and organizations.</p> <p>This has led to tremendous increase in the usage of mobile devices in the country.</p> <p>Now a days, mobile devices have become an important part of personal and business life of people and organizations.</p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#statistics-of-mobile-usage-in-india-", "title": "Statistics of Mobile Usage in India \ud83c\uddee\ud83c\uddf3", "text": "<p>India\u2019s smartphone market is projected to grow rapidly until 2025. The growth is driven by availability of cheap mobile data. </p> <p> Mobile usage statistics </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#statistics-of-internet-usage-in-india-", "title": "Statistics of Internet Usage in India \ud83c\uddee\ud83c\uddf3", "text": "<p> Internet usage statistics </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#statistics-of-mobile-payments-in-india-", "title": "Statistics of Mobile Payments in India \ud83c\uddee\ud83c\uddf3", "text": "<p>India is home to the world\u2019s fastest growing proximity payment market.</p> <p> Total number of Digital Payments, in Billion, India, 2018 to 2022 </p> <p>The India Mobile Payments Market size is expected to grow from USD 0.64 trillion in 2023 to USD 2.06 trillion by 2028, at a CAGR of 26.52% during the forecast period (2023-2028).</p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#app-stats-and-trends", "title": "App Stats and Trends", "text": "<p>As of 21 December 2023, there are 38,22,760 apps on Google Play and 17,96,419 apps on the Apple App Store. Mobile applications on app-stores </p> <p>The chart ranks the top categories on Google Play based on the number of apps that compose them.</p> <p> Top ranked mobile apps categories </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#current-state-of-mobile-security", "title": "Current State of Mobile Security", "text": "<p>This tremendous increase in the usage of mobile devices has led to huge amounts of personal and business related data being stored and accessed on the mobile devices.</p> <p>This same reason has become the motivation for hackers and attackers to target these devices which have become mini hubs of rich data.</p> <p>Android is by large the most widely adopted mobile platform in the world powering over 4.78 billion devices across the globe.</p> <ul> <li>Main reason for the popularity of Android is its openness &amp; strong eco-system.<ul> <li>OEMs</li> <li>Developers</li> <li>Freelancers -Users</li> </ul> </li> </ul> <p> Android OS market share </p> <ul> <li> <p>Bulk of the mobile phones in India are running a very old version of Android.</p> </li> <li> <p>Mobile hardware is not manufactured in the country nor is the software that runs on it.</p> </li> <li> <p>Even the anti-malware solutions being used in the country are neither designed nor developed in the country.</p> </li> <li> <p>A report from Qualcomm says wallets and mobile banking applications in India are not using hardware level security which can make online transactions more secure.</p> </li> <li> <p>There are numerous fake banking applications and wallets detected in the Google playstore targeting victims in India which mimic the names or graphic design specifications of existing apps. </p> </li> <li> <p>Insecure mobile browsers are posing a serious threat to the security and privacy of mobile users in the country.</p> </li> <li> <p>Anti-Virus companies such as Quick-Heal, Kaspersky etc are extracting lot of analytical information from the users.</p> </li> <li> <p>There is a possibility of increased threat landscape in the country with the introduction of 5G.</p> </li> </ul> <p>There has been a rise in detected malware for Android platforms by more than 400% over the past 12 months. This is alarming and further raises security concerns for Android app users. Increasing mobile malware attacks </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#why-security-is-important", "title": "Why security is important?", "text": "<p> Importance of mobile security </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#what-is-mobile-security", "title": "What is Mobile Security?", "text": "<ul> <li> <p>Mobile security is all about securing your smartphone from digital risks and dangers.</p> </li> <li> <p>With phones storing loads of personal data, mobile security becomes crucial to prevent attempts by cyber intruders.</p> </li> </ul>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#mobile-threats-landscape", "title": "Mobile Threats Landscape", "text": "", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#what-are-mobile-threats", "title": "What are Mobile Threats?", "text": "<p>Mobile security threats are attacks that are intended to compromise or steal data from mobile devices like smartphones and tablets. </p> <p>These threats often take the form of malware or spyware, giving bad actors unauthorized access to a device; in many cases, users aren\u2019t even aware that an attack has occurred.</p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#mobile-threat-statistics", "title": "Mobile Threat Statistics", "text": "<p>According to Kaspersky Security Network, in Q2 2023:</p> <ul> <li>A total of 5,704,599 mobile malware, adware, and riskware attacks were detected.</li> <li>The most common threat to mobile devices was potentially unwanted software (RiskTool): 30.8% of all threats detected.</li> <li>A total of 370,327 malicious installation packages were detected, of which:<ul> <li>59,167 packages were related to mobile banking trojans,</li> <li>1318 packages were mobile ransomware trojans.</li> </ul> </li> </ul> <p>The number of malware, adware, or unwanted software attacks on mobile devices began to climb again in Q2 2023. Rise in malwares in Q2 2023 </p> <p>In Q4 2022, we observed a noticeable decline in the number of malware installers due to decreased activity by Trojan.</p> <p>Q1 2023 saw a slight increase in the number of new malware samples, which continued into Q2. Decline in malwares in Q4 2023 </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#major-mobile-threats", "title": "Major Mobile Threats", "text": "", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#adware", "title": "Adware", "text": "<p> Adware </p> <ul> <li> <p>Adware is unwanted software designed to throw advertisements up on your screen.</p> </li> <li> <p>Adware, in general, collects personal information from the device such as phone number, email address, application accounts, International Mobile Equipment Identity (IMEI) number of the device, device ID, and status. </p> </li> </ul>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#spyware", "title": "Spyware", "text": "<p> Spyware </p> <ul> <li> <p>Spyware is malware that secretly observes your activities without permission and reports it to the software\u2019s author.</p> </li> <li> <p>It can track your logins and passwords, as well as track your phone itself and extract your most sensitive information, including your GPS location.</p> </li> </ul>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#trojan", "title": "Trojan", "text": "<p> Trojan </p> <ul> <li> <p>A Trojan works by presenting itself as something useful like an app or attachment in order to trick you into downloading it. </p> </li> <li> <p>Trojan attacks can hide anything from malware that allows the attacker unauthorized access to spyware that steals financial information.</p> </li> </ul>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#ransomware", "title": "Ransomware", "text": "<p> Ransomware </p> <ul> <li> <p>Ransomware is a form of malware that locks you out of your device and encrypts your files, then forces you to pay to get your files back using hard-to-trace cryptocurrencies. </p> </li> <li> <p>Ransomware has been called the cyber criminal\u2019s weapon of choice because it\u2019s easy to obtain on online criminal marketplaces, difficult to defend against, and even more difficult to remove. Most victims have no choice but to pay up.</p> </li> </ul>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#fakehidden-apps", "title": "Fake/Hidden Apps", "text": "<p> Fake or Hidden Apps </p> <ul> <li> <p>Hidden administrator apps are a type of malware that target Android devices. </p> </li> <li> <p>These threats are characterized by stealth implementation and elevated user privileges, so you don\u2019t easily see them, and they can do more than a regular app can.</p> </li> <li> <p>Fake mobile applications are applications that mimic the look and/or functionality of legitimate applications to trick unsuspecting users to install them.</p> </li> <li> <p>They are designed to resemble legitimate apps but instead carry out malicious activities. These activities include monitoring your activity, installing malware, showing annoying ads, or stealing your personal information.</p> </li> <li> <p>Hidden administrator apps are a type of malware that target Android devices. These threats are characterized by stealth implementation and elevated user privileges, so you don\u2019t easily see them, and they can do more than a regular app can.</p> </li> </ul>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#circulation-of-threats", "title": "Circulation of Threats", "text": "<p> How Threats Spread </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#signs-your-phone-might-be-tapped", "title": "Signs Your Phone Might Be Tapped", "text": "<p>How to tell if your phone is tapped, tracked, tapped, or monitored by spy software?</p> <p> Signs of device tapping </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#reporting-fraud-or-attacks", "title": "Reporting Fraud or Attacks", "text": "<p>What to Do When Trouble Strikes Reporting Incidents </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#national-cyber-crime-reporting-portal-ncrp", "title": "National Cyber Crime Reporting Portal (NCRP)", "text": "<p>GoI initiative to facilitate victims to report cyber crime complaints online.</p> <p> NCRP </p> <p> </p> <p>https://cybercrime.gov.in/</p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#citizen-financial-cyber-fraud-reporting--management-system-cfcfrms", "title": "Citizen Financial Cyber Fraud Reporting &amp; Management System (CFCFRMS)", "text": "<p>To deal with the complex subject of financial frauds.</p> <p> CFCFRMS </p> <p> </p> <p>Helpline Number: 1930</p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#central-equipment-identity-register-ceir", "title": "Central Equipment Identity Register (CEIR)", "text": "<p>Online portal for tracing stolen or lost mobile phones.</p> <p> CEIR </p> <p> </p> <p>https://www.ceir.gov.in/</p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#counter-measures-to-mobile-threats", "title": "Counter Measures to Mobile Threats", "text": "<p> Practical Security Tips </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#emerging-jobs-in-mobile-security-domain", "title": "Emerging Jobs in Mobile Security Domain", "text": "<ul> <li> <p>Mobile Security Market size was valued at USD 8.5 billion in 2022. </p> </li> <li> <p>The Mobile Security market industry is projected to grow from USD 9.367 Billion in 2023 to USD 20.372 billion by 2032.</p> </li> </ul> <p> Mobile Security Market </p> <ul> <li>India is the fastest growing mobile security market in the world.</li> </ul> <p></p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#job-landscape-in-india-", "title": "Job Landscape in India \ud83c\uddee\ud83c\uddf3", "text": "<p> Rising demand in cybersecurity </p> <p>The India Cybersecurity Market size is estimated at USD 3.97 billion in 2023, and is expected to reach USD 9.21 billion by 2028, growing at a CAGR of 18.33% during the forecast period (2023-2028). </p> <p> Indian Cybersecurity Market </p> <p>Here is a quick summary of a few aspects of the cybersecurity industry in India, making it a promising career choice.</p> <ul> <li> <p>The National Association of Software and Services Companies (NASSCOM) reported that India lacks skilled cyber security specialists regardless of having the largest global IT talent pool.</p> </li> <li> <p>According to news, there were over 40, 000 Cyber Security jobs available in India as of mid 2023.</p> </li> <li> <p>And, according to PayScale, an Information Security Manager in India can earn an average salary of \u20b919,32,475 per annum.</p> </li> </ul>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#percentage-of-cybersecurity-professionals-by-experience", "title": "Percentage of Cybersecurity Professionals by Experience", "text": "<p> Professionals by Experience </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#percentage-of-cybersecurity-personnel-across-salary-brackets", "title": "Percentage of Cybersecurity Personnel across Salary Brackets", "text": "<p> Personnel across Salary Brackets </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#city-wise-job-comparison", "title": "City-wise job Comparison", "text": "<p> City-wise job Comparison </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#sector-wise-job-break-up", "title": "Sector-wise Job Break-up", "text": "<p>(Excluding IT Software Services, Consulting, and Network / Security Firms)</p> <p> Sector-wise Job Break-up </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#percentage-of-jobs---organization-type", "title": "Percentage of Jobs - Organization Type", "text": "<p> Percentage of Jobs - Organization Type </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#cyber-security-career-options", "title": "Cyber Security Career Options", "text": "<p>Following Cyber Security jobs in India witnessed an increase in demand due to the shortage of skilled Cyber Security specialists:</p> <p> Cyber Security Career Options </p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#how-to-start-a-cyber-security-career", "title": "How to Start a Cyber Security Career?", "text": "", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#academic-background", "title": "Academic Background", "text": "<p>Degrees in cybersecurity, computer science &amp; engineering, information technology, or related fields.</p>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#certifications", "title": "Certifications", "text": "<ul> <li>Certified Information System Security Professional (CISSP)</li> <li>CompTIA Security+ </li> <li>Certified Ethical Hacker (CEH v11)</li> <li>Certified Cloud Security Professional (CCSP)</li> <li>Information System Security Architecture Professional (ISC)</li> <li>Certified Information System Auditor (CISA)</li> <li>Certified Information Systems Security Professional (CISM)</li> <li>Information Systems Security Management Professionals (CISSP-ISSMP)</li> <li>Certified Mobile and Web App Penetration Tester (CMWAPT)  </li> </ul>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#skill-development", "title": "Skill Development", "text": "<ul> <li>Proficiency in programming languages.</li> <li>Familiarity with operating systems.</li> <li>Training on security frameworks and tools.</li> <li>Importance of staying updated with the latest industry trends.</li> </ul>", "tags": ["mobile security trends, mobile security jobs"]}, {"location": "posts/mobile-security/mobile-security-trends-2023/#conclusion", "title": "Conclusion", "text": "<p>Empower Your Digital Life: Taking Charge of Security</p> <p> Taking Charge of Security </p>", "tags": ["mobile security trends, mobile security jobs"]}]}